package main

/*  数组切片
	在前一节里我们已经提过数组的特点：数组的长度在定义之后无法再次修改；数组是值类型，每次传递都将产生一份副本。显然这种数据结构无法完全满足开发者的真实需求。
	不用失望， Go语言提供了数组切片（ slice）这个非常酷的功能来弥补数组的不足。
	初看起来，数组切片就像一个指向数组的指针，实际上它拥有自己的数据结构，而不仅仅是个指针。数组切片的数据结构可以抽象为以下3个变量：
	 一个指向原生数组的指针；
	 数组切片中的元素个数；
	 数组切片已分配的存储空间。
	从底层实现的角度来看，数组切片实际上仍然使用数组来管理元素，因此它们之间的关系让C++程序员们很容易联想起STL中std::vector和数组的关系。
	基于数组，数组切片添加了一系列管理功能，可以随时动态扩充存放空间，并且可以被随意传递而不会导致所管理的元素被重复复制。
 */

/*  创建数组切片
	创建数组切片的方法主要有两种——基于数组和直接创建，下面我们来简要介绍一下这两种方法。
	 基于数组
	数组切片可以基于一个已存在的数组创建。数组切片可以只使用数组的一部分元素或者整个
	数组来创建，甚至可以创建一个比所基于的数组还要大的数组切片。代码清单2-1演示了如何基
	于一个数组的前5个元素创建一个数组切片。
	package main
	import "fmt"
	func main() {
	// 先定义一个数组
	var myArray [10]int = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	// 基于数组创建一个数组切片
	var mySlice []int = myArray[:5]
	fmt.Println("Elements of myArray: ")
	for _, v := range myArray {
	fmt.Print(v, " ")
	}
	fmt.Println("\nElements of mySlice: ")
	for _, v := range mySlice {
	fmt.Print(v, " ")
	}
	fmt.Println()

	基于myArray的所有元素创建数组切片：
	mySlice = myArray[:]
	基于myArray的前5个元素创建数组切片：
	mySlice = myArray[:5]
	基于从第5个元素开始的所有元素创建数组切片：
	mySlice = myArray[5:]

	 直接创建
	并非一定要事先准备一个数组才能创建数组切片。 Go语言提供的内置函数make()可以用于
	灵活地创建数组切片。下面的例子示范了直接创建数组切片的各种方法。
	创建一个初始元素个数为5的数组切片，元素初始值为0：
	mySlice1 := make([]int, 5)
	创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间：
	mySlice2 := make([]int, 5, 10)
	直接创建并初始化包含5个元素的数组切片：
	mySlice3 := []int{1, 2, 3, 4, 5}
	当然，事实上还会有一个匿名数组被创建出来，只是不需要我们来操心而已。
 */

/*	元素遍历
	1、按下标循环遍历
	2、以range遍历
	for i, v := range mySlice {
		fmt.Println("mySlice[", i, "] =", v)
	}
*/



func main() {
	
}
